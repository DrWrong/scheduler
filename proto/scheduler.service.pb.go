// Code generated by protoc-gen-go. DO NOT EDIT.
// source: scheduler.service.proto

/*
Package proto is a generated protocol buffer package.

It is generated from these files:
	scheduler.service.proto

It has these top-level messages:
	AckResponse
	TaskAck
	Task
	ScheduleTaskRequest
	ScheduleTaskResponse
	FetchTaskRequest
*/
package proto

import proto1 "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto1.ProtoPackageIsVersion2 // please upgrade the proto package

type AckResponse struct {
}

func (m *AckResponse) Reset()                    { *m = AckResponse{} }
func (m *AckResponse) String() string            { return proto1.CompactTextString(m) }
func (*AckResponse) ProtoMessage()               {}
func (*AckResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type TaskAck struct {
	Topic      string `protobuf:"bytes,1,opt,name=topic" json:"topic,omitempty"`
	Id         string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	Successed  bool   `protobuf:"varint,3,opt,name=successed" json:"successed,omitempty"`
	Result     []byte `protobuf:"bytes,4,opt,name=result,proto3" json:"result,omitempty"`
	ScheduleAt int64  `protobuf:"varint,5,opt,name=scheduleAt" json:"scheduleAt,omitempty"`
}

func (m *TaskAck) Reset()                    { *m = TaskAck{} }
func (m *TaskAck) String() string            { return proto1.CompactTextString(m) }
func (*TaskAck) ProtoMessage()               {}
func (*TaskAck) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *TaskAck) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *TaskAck) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *TaskAck) GetSuccessed() bool {
	if m != nil {
		return m.Successed
	}
	return false
}

func (m *TaskAck) GetResult() []byte {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *TaskAck) GetScheduleAt() int64 {
	if m != nil {
		return m.ScheduleAt
	}
	return 0
}

type Task struct {
	// 任务ID
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// 任务所在的topic
	Topic string `protobuf:"bytes,2,opt,name=topic" json:"topic,omitempty"`
	// 任务原来ID， 由它保证任务仅能提交一次， 为空时，表示任务可以被提交多次
	OriginalID string `protobuf:"bytes,3,opt,name=originalID" json:"originalID,omitempty"`
	// 任务名称
	Name string `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
	// 执行参数
	Payload []byte `protobuf:"bytes,5,opt,name=payload,proto3" json:"payload,omitempty"`
	// 任务执行时间 为0时表示立即执行
	ScheduleAt int64 `protobuf:"varint,6,opt,name=scheduleAt" json:"scheduleAt,omitempty"`
	// 任务重试的次数， 超过重试次数后会被认为失败
	MaxRetryTime int64 `protobuf:"varint,7,opt,name=maxRetryTime" json:"maxRetryTime,omitempty"`
	// 任务执行的结果
	Result []byte `protobuf:"bytes,8,opt,name=result,proto3" json:"result,omitempty"`
	// 任务重试的次数
	RetriedTime int64 `protobuf:"varint,9,opt,name=retriedTime" json:"retriedTime,omitempty"`
}

func (m *Task) Reset()                    { *m = Task{} }
func (m *Task) String() string            { return proto1.CompactTextString(m) }
func (*Task) ProtoMessage()               {}
func (*Task) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Task) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Task) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *Task) GetOriginalID() string {
	if m != nil {
		return m.OriginalID
	}
	return ""
}

func (m *Task) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Task) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *Task) GetScheduleAt() int64 {
	if m != nil {
		return m.ScheduleAt
	}
	return 0
}

func (m *Task) GetMaxRetryTime() int64 {
	if m != nil {
		return m.MaxRetryTime
	}
	return 0
}

func (m *Task) GetResult() []byte {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *Task) GetRetriedTime() int64 {
	if m != nil {
		return m.RetriedTime
	}
	return 0
}

type ScheduleTaskRequest struct {
	Topic      string  `protobuf:"bytes,1,opt,name=topic" json:"topic,omitempty"`
	BatchTasks []*Task `protobuf:"bytes,2,rep,name=batchTasks" json:"batchTasks,omitempty"`
}

func (m *ScheduleTaskRequest) Reset()                    { *m = ScheduleTaskRequest{} }
func (m *ScheduleTaskRequest) String() string            { return proto1.CompactTextString(m) }
func (*ScheduleTaskRequest) ProtoMessage()               {}
func (*ScheduleTaskRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ScheduleTaskRequest) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *ScheduleTaskRequest) GetBatchTasks() []*Task {
	if m != nil {
		return m.BatchTasks
	}
	return nil
}

type ScheduleTaskResponse struct {
	BatchTasks []*Task `protobuf:"bytes,1,rep,name=batchTasks" json:"batchTasks,omitempty"`
}

func (m *ScheduleTaskResponse) Reset()                    { *m = ScheduleTaskResponse{} }
func (m *ScheduleTaskResponse) String() string            { return proto1.CompactTextString(m) }
func (*ScheduleTaskResponse) ProtoMessage()               {}
func (*ScheduleTaskResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *ScheduleTaskResponse) GetBatchTasks() []*Task {
	if m != nil {
		return m.BatchTasks
	}
	return nil
}

type FetchTaskRequest struct {
	Topic string `protobuf:"bytes,1,opt,name=topic" json:"topic,omitempty"`
}

func (m *FetchTaskRequest) Reset()                    { *m = FetchTaskRequest{} }
func (m *FetchTaskRequest) String() string            { return proto1.CompactTextString(m) }
func (*FetchTaskRequest) ProtoMessage()               {}
func (*FetchTaskRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *FetchTaskRequest) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func init() {
	proto1.RegisterType((*AckResponse)(nil), "AckResponse")
	proto1.RegisterType((*TaskAck)(nil), "TaskAck")
	proto1.RegisterType((*Task)(nil), "Task")
	proto1.RegisterType((*ScheduleTaskRequest)(nil), "ScheduleTaskRequest")
	proto1.RegisterType((*ScheduleTaskResponse)(nil), "ScheduleTaskResponse")
	proto1.RegisterType((*FetchTaskRequest)(nil), "FetchTaskRequest")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Scheduler service

type SchedulerClient interface {
	ScheduleTask(ctx context.Context, in *ScheduleTaskRequest, opts ...grpc.CallOption) (*ScheduleTaskResponse, error)
	FetchTask(ctx context.Context, in *FetchTaskRequest, opts ...grpc.CallOption) (Scheduler_FetchTaskClient, error)
	AckTask(ctx context.Context, in *TaskAck, opts ...grpc.CallOption) (*AckResponse, error)
}

type schedulerClient struct {
	cc *grpc.ClientConn
}

func NewSchedulerClient(cc *grpc.ClientConn) SchedulerClient {
	return &schedulerClient{cc}
}

func (c *schedulerClient) ScheduleTask(ctx context.Context, in *ScheduleTaskRequest, opts ...grpc.CallOption) (*ScheduleTaskResponse, error) {
	out := new(ScheduleTaskResponse)
	err := grpc.Invoke(ctx, "/Scheduler/ScheduleTask", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerClient) FetchTask(ctx context.Context, in *FetchTaskRequest, opts ...grpc.CallOption) (Scheduler_FetchTaskClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Scheduler_serviceDesc.Streams[0], c.cc, "/Scheduler/FetchTask", opts...)
	if err != nil {
		return nil, err
	}
	x := &schedulerFetchTaskClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Scheduler_FetchTaskClient interface {
	Recv() (*Task, error)
	grpc.ClientStream
}

type schedulerFetchTaskClient struct {
	grpc.ClientStream
}

func (x *schedulerFetchTaskClient) Recv() (*Task, error) {
	m := new(Task)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *schedulerClient) AckTask(ctx context.Context, in *TaskAck, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := grpc.Invoke(ctx, "/Scheduler/AckTask", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Scheduler service

type SchedulerServer interface {
	ScheduleTask(context.Context, *ScheduleTaskRequest) (*ScheduleTaskResponse, error)
	FetchTask(*FetchTaskRequest, Scheduler_FetchTaskServer) error
	AckTask(context.Context, *TaskAck) (*AckResponse, error)
}

func RegisterSchedulerServer(s *grpc.Server, srv SchedulerServer) {
	s.RegisterService(&_Scheduler_serviceDesc, srv)
}

func _Scheduler_ScheduleTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScheduleTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).ScheduleTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Scheduler/ScheduleTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).ScheduleTask(ctx, req.(*ScheduleTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scheduler_FetchTask_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FetchTaskRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SchedulerServer).FetchTask(m, &schedulerFetchTaskServer{stream})
}

type Scheduler_FetchTaskServer interface {
	Send(*Task) error
	grpc.ServerStream
}

type schedulerFetchTaskServer struct {
	grpc.ServerStream
}

func (x *schedulerFetchTaskServer) Send(m *Task) error {
	return x.ServerStream.SendMsg(m)
}

func _Scheduler_AckTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskAck)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).AckTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Scheduler/AckTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).AckTask(ctx, req.(*TaskAck))
	}
	return interceptor(ctx, in, info, handler)
}

var _Scheduler_serviceDesc = grpc.ServiceDesc{
	ServiceName: "Scheduler",
	HandlerType: (*SchedulerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ScheduleTask",
			Handler:    _Scheduler_ScheduleTask_Handler,
		},
		{
			MethodName: "AckTask",
			Handler:    _Scheduler_AckTask_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "FetchTask",
			Handler:       _Scheduler_FetchTask_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "scheduler.service.proto",
}

func init() { proto1.RegisterFile("scheduler.service.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 391 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x92, 0xc1, 0x8e, 0xd3, 0x30,
	0x10, 0x86, 0xe5, 0xb4, 0x69, 0x9a, 0x69, 0x40, 0x60, 0x0a, 0x58, 0x15, 0x5a, 0x85, 0x48, 0x88,
	0x9c, 0x2c, 0xb4, 0x1c, 0x11, 0x87, 0x20, 0x84, 0xc4, 0xd5, 0xec, 0x89, 0x5b, 0xd6, 0x19, 0x51,
	0x2b, 0x69, 0x13, 0x6c, 0x07, 0xd1, 0x07, 0xe0, 0x0d, 0x78, 0x58, 0x8e, 0xa8, 0x6e, 0x5a, 0xdc,
	0xa8, 0xe5, 0x94, 0xcc, 0x9f, 0xf9, 0xf3, 0x7f, 0x63, 0x0f, 0x3c, 0x37, 0x72, 0x8d, 0x55, 0xdf,
	0xa0, 0xe6, 0x06, 0xf5, 0x0f, 0x25, 0x91, 0x77, 0xba, 0xb5, 0x6d, 0xf6, 0x00, 0x16, 0x85, 0xac,
	0x05, 0x9a, 0xae, 0xdd, 0x1a, 0xcc, 0x7e, 0x11, 0x88, 0xee, 0x4a, 0x53, 0x17, 0xb2, 0xa6, 0x4b,
	0x08, 0x6d, 0xdb, 0x29, 0xc9, 0x48, 0x4a, 0xf2, 0x58, 0x1c, 0x0a, 0xfa, 0x10, 0x02, 0x55, 0xb1,
	0xc0, 0x49, 0x81, 0xaa, 0xe8, 0x0b, 0x88, 0x4d, 0x2f, 0x25, 0x1a, 0x83, 0x15, 0x9b, 0xa4, 0x24,
	0x9f, 0x8b, 0x7f, 0x02, 0x7d, 0x06, 0x33, 0x8d, 0xa6, 0x6f, 0x2c, 0x9b, 0xa6, 0x24, 0x4f, 0xc4,
	0x50, 0xd1, 0x1b, 0x80, 0x23, 0x51, 0x61, 0x59, 0x98, 0x92, 0x7c, 0x22, 0x3c, 0x25, 0xfb, 0x43,
	0x60, 0xba, 0xe7, 0x18, 0xe2, 0xc8, 0x29, 0xee, 0x04, 0x15, 0xf8, 0x50, 0x37, 0x00, 0xad, 0x56,
	0xdf, 0xd4, 0xb6, 0x6c, 0x3e, 0x7f, 0x74, 0x14, 0xb1, 0xf0, 0x14, 0x4a, 0x61, 0xba, 0x2d, 0x37,
	0xe8, 0x20, 0x62, 0xe1, 0xde, 0x29, 0x83, 0xa8, 0x2b, 0x77, 0x4d, 0x5b, 0x56, 0x2e, 0x3f, 0x11,
	0xc7, 0x72, 0x04, 0x37, 0x1b, 0xc3, 0xd1, 0x0c, 0x92, 0x4d, 0xf9, 0x53, 0xa0, 0xd5, 0xbb, 0x3b,
	0xb5, 0x41, 0x16, 0xb9, 0x8e, 0x33, 0xcd, 0x1b, 0x7c, 0x7e, 0x36, 0x78, 0x0a, 0x0b, 0x8d, 0x56,
	0x2b, 0xac, 0x9c, 0x35, 0x76, 0x56, 0x5f, 0xca, 0x04, 0x3c, 0xf9, 0x32, 0x64, 0xed, 0x4f, 0x40,
	0xe0, 0xf7, 0x1e, 0x8d, 0xbd, 0x72, 0x1b, 0xaf, 0x00, 0xee, 0x4b, 0x2b, 0xd7, 0xfb, 0x4e, 0xc3,
	0x82, 0x74, 0x92, 0x2f, 0x6e, 0x43, 0xee, 0x7c, 0xde, 0x87, 0xec, 0x3d, 0x2c, 0xcf, 0xff, 0x79,
	0xb8, 0xee, 0x91, 0x9d, 0x5c, 0xb3, 0xe7, 0xf0, 0xe8, 0x13, 0x0e, 0xd5, 0x7f, 0x79, 0x6e, 0x7f,
	0x13, 0x88, 0x8f, 0x49, 0x9a, 0xbe, 0x83, 0xc4, 0x8f, 0xa5, 0x4b, 0x7e, 0x61, 0xb2, 0xd5, 0x53,
	0x7e, 0x91, 0xed, 0x35, 0xc4, 0xa7, 0x50, 0xfa, 0x98, 0x8f, 0x01, 0x56, 0x07, 0xce, 0x37, 0x84,
	0xbe, 0x84, 0xa8, 0x90, 0xb5, 0x6b, 0x9b, 0xf3, 0x61, 0x79, 0x57, 0x09, 0xf7, 0xd6, 0xfa, 0x43,
	0xf4, 0x35, 0x74, 0xeb, 0x7e, 0x3f, 0x73, 0x8f, 0xb7, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0xe5,
	0xa2, 0x1e, 0xe0, 0x10, 0x03, 0x00, 0x00,
}
